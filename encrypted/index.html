<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f676e020029b8310607761a07f59bff460703f150059198005eb0d31bdc8360d8fc7985226a2f6d3aece4fb3b0f1aa78997f85ac0091761a804c53e50a99d32add1a671cbd07900d4ad9583ba587f655a0544ba93cee017a524ead7eaabb91b3cbaf71c36a34a8042cecb6e217d13bccdccd5ce6860fe8e3defd7811ec794e16f9d12df3097cb45ba16a056988798624cbf79f1ce52095bdc96e93c8a74ef3fb2d69a9c6e6e2e10890e282ee789de410b39548f34df8fe9218a2c0619a1a75948a24ea59d0bb0b6d25a805eefc6357eb533555458dd0eb773090bc4fffa4bc6e191282d15d779367d3ba4513c7f2cea14196a0f5d9354b6b2f9287edd9bf017cc58cfd76b687edd559738d608f9eabcb222f0dd2437fa09642022b9705089bc010bdd733fb708f77d030ce954d0ef570e1c78218d9754ce0cf9fd52276914fe8ebc76159cc02dcddaec81617acc0f6a74958e8fdb67c3efa1e0775f2fe88d862f7031825ae2a8cc25c62b1fbf2bc470e1a605c4d71f99a50e4c78bafae4549432015d93d30443c8aefb3ab13a880db44997d0b0dfce1c2bb384ac3ee5f0e38a6c7bb25dc366a282c7b756423459281c59db755fc88c194d17bb76bb3c50eb638a8becc17f73771b01d31ce2515207462a02b57fc6c71b9b0fae4f14c598c468996ca389451cc1da141348f03ede470b2aa64c9ae3282ea56dae0047aad7e746da444b449b55a2e76b0129c152e37497653cc265f6530fb133bff4965247294a994e283c2931001cab024fbf481d103755053c33a8fcee94d8e2cc596fa32283c166343fc4e19e6334fae8b3dfbc0d9f0a7514058fbfcd7df6b6e48c35c697892c08f2fb8c1bb1a9ed708367063aad7b11665e4375e0b57539a34945aee3d4c8228ad99f340365823f596fcdcd986eb9b7b97ba53f9659e39583ad78e60fe3bb764b194728c24812507801a816cb7be4a8282684f4f3bef3f0dd8bdc548cf99617ebf8b09750515a75bffdfad86edad48ac708e2dcdaee059b1e9450c1794fe65c4c3a08e706d4ddf24b7caa2c105f1dc91505bf209b6fa6ac55408235b1d79377da3cf79735f547da10d7c8fa27e3729f189e1b229e96382ea5fa2634a471d8b959f4481eb213398c63d3f552d91b0547c7c892c3d609afd2229736fe42e62fd043afa91026a2a56a383e7f1cdcab40f82552cbc82a2e3fc7b54ab0f5c111a16df29dd03c7440763a6b98f986678db018287fc990f94579f048b76fb7aaa48cb4c0c5139efd4ffa1d1242c57a08573d56e578d15a278fc8f102034d312cb5d1a604f789ba1e70b7e61c928a5eac79efb09946df420ccfb46eea99460269a7a44a37a8c71ef21c340ff617b6c800922c9b15a850b167fd4b02942e86b29a0b9217fcd81b50ec7bb898ec3f71befa270f6bef5494f9bbecbf3df216076ef9ad6a8a9ee02bc4908364c680c43ebd47bb14d76218053e360678bc7a46e5807fb2a964d0150424ba7445fdfb4bbc2a703fa7ef733489ffa1d052e5e588414eecda5031086c604207ff22873abaa93bfab32c07afffe67271c4d1ef7b2ae83c52536c11d3bc386c28c4d0a62a7ed8f93764d05b6f915ec410bd8a85d4c574c1c095cb50ca59d917bb4dfb7eda66667c29eca793e570856ef57ef68d8806ed9a7c2e822f7dfa8e099ce1fefee50a11843acdfea219b875118bf5bd10b61ad398828459f6177b683e25d884dae1a36d8dc8ebae99c3bc52410d6d0b168641d58fb35b18261d8cec11470cf7f68969245ad708d01d105217608aa45038263a8415375447d5ffd69cf975efa1e608e4169d0385bfdbe0d9da273f1a1366e89b4c7c943fff6cbd647800d9b0fc034aa691c4733751c364c56feb739d9171c82b5af4f450d592c68be56568947ab6a319e6d799b386a6292433ace2e4af0bdd772d5375647c45a7b487df162be73a3103e6f6d533b51d4fa98f89cfcedfd4dc05ff225b7505d3a5dd6f544aefca82568be39146ffeb6d3aad0a73a96b7e9bea36afc532e537dd965c5ae7472a8cef4946cdad7afff1de24bc62d9a287dc5e284a9aa6e66cbedb099e0ecedcba73d8f2f6d1339a45b31d07e6e60772f34650580ddd77ddff43ae3a15b6118cb322668a3779bd07754465d0c7a33e966cc34169db77309a60ff9d66762fdcc0595a4d862b42b2bf14e6b021a0a0b4005bee449b77da873db77d442ffcde7fedc3a838389a892ed52548c8b964addc438f82061cd203cb3372541a9d032df950d67eb271fd8205238afd0ccc4492284992afd1fdd674df42327ff659fe174494035e776d5669f8238bc457c9277317792a021d654667ae26fc928498d34d9afeea987316165aba9c87cc876e885c9523ad85f64381e14f7751211d90ba7318562271e3483915a25d2d0e9c79b69dd6a7c41edb244a5b8cb75cc0a9350adacee8ba97dfd0fec301a9e7f5e7a208940e5ec1120ccd7aa793a8fe262e840d92f101474ec2eb57b1b157ccceb29a224e35b0c132b0d184d6043fd254977223891aada8ee19f2ee4242170998d4ac88d714f9d37eae252b9ee0948b1ba607642f9c74fd94065cf419312fcd48a4cab3f574f6f1db44043df8a964524d00a39e6537f4f21b0751559570addffd69a020f4e1f739c82b4601f8a9c9b8bf1f4e913853e92619c20896dbdfc39f311f19b10d644b3da1675dddbe02138f5a9d7936d9691e8175510505443584fae09504a186d024cba84a0c5e928e5e67d5cae34c030dd13409a52322f97037ce6ebaaf255a6750e646571d946a0271112893ecc1b0e30c33a367f0993058515f519f03b931437e4b3cf5d8a6a4eefa30d7b0742a7133e1ccf960fd8d9623492f5f7ccd9bf20e5dcca5f0de9028abf2a0ee32dc80ede9388d6ef8471193199cfac5975af71d60954c0e273a882c35201b39c82fce43a8216061e7abbcddeb2fac5a48eb52315df5d15883c4fcd626a9edf7cd61c26bde70512202bc72e8af62c4a9881ba829e3346ec448e8d7d20438caf3d3f06aed88a82f62867749e40b502188d260cd80654f77d1a1b15cdee3fa41a07ab4598d9f2cb8b8f2cbd752da3bdb57e36990e197b20dd90cfafbc136eedd32ef67cfe61bcf4f951f68426848cf332514373be7706cf81a3f96a18b74227ce9892fbe93578bd4157b618151230dd51ee76798c37f2c47f9b296d29a72faba676752a20588b213a6c9a5c3704a754b61cba90438a010f273dc455ee28cfefd070b36225aa51a0b37687483c840711189eb364142adb15b0cb80c7d743eeba8d73a19ac6bfb2472693b7fbd9f72d4fe475b3ce5ce8c2e949a8110973723964f299256ef27669e10080bc2e132a4f0a7cdb0cb2f295fe0d082ff157007b85330dff0cb397784a2866747e3896e681a4ce1b08d7122ebb7a4f67c1850b299198f0de0f25c0d33e7dc743886bf1f108606b1d64928c517849e9c42425413def335b0328b511550432a90a39a4ff32c62ce987308e38e4ae42a9750bdf9bc7187f062de36c5f963c00e26079ea8ba836f89f1685d3c367d77044e8054436613ae5ed15a8c7d7302af7ef7f364ed69ec5f2f7fef13333e0cb89698ae8541d3af6b5aad6e3e39f505476394f1cba099f0a393116cf2698d958d0ed61fca40b62454a18ad2e9a84f6a03e6902120f8da64450367532da607945e051c802bd1907a32910c725d4624018293d64dd00bc12d9d90d811a8e532eb5d7ee75ea1658ce4da04310fb8d1f67aa14f29a494470770da65e370f39228c75cc4204d66193286a4c3f4c7e7d6510e13ed51231bf7ea7d94b9e127aed74e603b64a9e8688975b12639c6917aca192656b8d6ecad7134652329c699668191997a540f80461de940452073251544052b83adde0a85159f633e95918cc6baaffc224d1d780c09ecfc2ca367c5ddde84fa15f0b7e2f470f4bd01a1e3bde927bc8e8cd7261829606155025c713892ae146b8f02cdffc57b5784f6d3d6062c5b8f5585e487247749aad93739a506dfd9a98c18acff62751d73fd72c212dab1728c5b7dc179f63d98807dbb7b8c27f3e5c7f8f3102655219f0134344a9513493a4677d9b3e50ef9908ff9636e8cfa87128d0bf4a2e9f8f20408716951a4234ba200b15fe81b48aa785fdfd0b7531ba6b548d62fdf3ef320ffb5755739723a1d36c53fbee565273df7d120310a1fea400a07ca07ecb4906d46084cbda361da56e34f6877f8af245ef703d9738d85ec3c1efea54a5f6e15008220d0fd48ab840a61b8ab2b097a661066321a11ad398537b9c6482a146ea3fd2d8c6925cfbc61ead6e2c86d624089c0309f1c1831f6d51e0ead9d8513de7ff437f7989625bfa3a6c8b4730b19e1f1345cd253583abc008578e5d5a7deaf40d8c839f5fe7e4edb0624af9e931554dfd9a315277db7e84723fd5fdbc568cd6fa303058b95ae4b47fbd6d290de157954c3a8e20dfd968d79cb5bc74930feb0ff3e8a5233e03311c9884dca5c2eb871baa760568934b5fc372d609ee1782256f81254c5dbe2ceca403db1ea6df83e3c6017aedcabea86705c2b4bfd5c778a82762939115bfb56e64a75486ccf4150d6baaaae3d5e30e393ee48c64fb7b4735222e796044219fc19ba45a68d734f5614456f855223c8107161860f886c83aa576e5b295f0e7028c248b3b77d3e337b4a662cdd7117fe840689f00fb81c6f6c8cfbe13c6398578d4590b4daf4648236d829b1322d00ceb8d15f7488ad01a71fe46668760c6a08f3aa9223aad3e661023071c7e65a19aa3ca786e64e473f8e97f164357e8624b158a1e812e705fc089ec1be2db30860f000eb10e57cee8c05292c955530eedee9623210cc4f4828ea5c1eecdcbe6ae9c71d404830210b9111be050ea041cae9340c6c58edd4e01fc4b0ccc53cf6ceb6e3dab907bada8c1a56984453e76b3034495f7938375e2b6501df5a96480dc75770cdf6d05fe407ebddf793ea1cfd6e8b39585c0101f63d7d6eae94e8be3ce48f9672221efe90410b12219e2a873ddc7a889562d5a8ce435cf7ee19d34904f3f33c2ff9fe7cbe98bbc87a726b74d840bce6dea60dc253f1b1d17ee8f0139aa63e6aedba1345b7d0447c28ab19b5565d7cda4c25182ebfea8089687a1acea070f7e815f6aba87b1a9bee35077f62d9223370294cc15a10014a0926f765d336b098fe9cef58dca0b8e87035d0cd1062e1593d2110a036d70d8baea30fe3fbf0b99fe27117ba858ce75444f25e9a72b4ef5b63b4d51e14f2c5eea0ee84b8a6c91cd04168dc37f8991e359354c4d939d45396466516bbfe6c3104d7899cbb5f565b091e209ada172587d7df9587b887686c6ed435e430510582fd8f1b4e4015d9e872e198a05950c444b746fda9c379d8d94940b195564b376b4ee886f48a00418d62c95d73901b1b3edc1ca70a68b25629863240b456bf74298ccabdeed43badbdbee074da3f932c831d1c34bd18e0e4c69550b5d218c5df1ae4653724041b7b281b32eb66b254c760cd38a0cf66633deb03742f339b366995f90cc837f9b714fe2f1b6ea63415bba70b75f03e5f5cb974221b2e02ac748daabc16f95307f62c048038d3b4a3620cc6aab8c0c829e2d3758139dfeb70771a5da315765cddfaa64cf81d149e8b97062a486756ba51a9d8f5fef51871c947253b206cd8ad04974436542380e46d5855de92d63a8c33ec3aade155be6a0447e63f2e7118d734a2692b2c7e7db17604c1b52cd4fbc8a31f278167e541593db3c915f81a05d0c1d45dc121f5c42aac050212d4c51e0da08c37c353193168f2f611dd9dd3076ff13fc41c0874daaff85b6e464b7798f8cc25b44ab283229d8939d6c91b0b863ba9528aaea2eee05a39d0d590d58b0cb02c0b6ff7b685755fea029aa756527533cb83714493cca02c4ac43f10989201f352710faad77a2d7556b4b9519eb23830394c60aa56f8f477b58d7d4f867d820f6e8174225ed1f20953c5a51af99f6d9feaf902bd5e112010e290ea332c0221a22de0d5966c1122f777ba26f26602d628a717f736a808fe89a3e67a7dab2d52e11776234fdd08b33b5ce142efe36f3ac47539375e1115e90d319898ab4ed26050c116b2ab43cafaa9a69d7919e492a86c726bde579fb92f7ac800fad7074c9da5037eb54d22c312359f6ce4091591e8304c7aa423d657cee4b4f8ad16fcd3af5ac744b5fef9c976b113318cb970471bee1d6900abebeda34759bd38cc86106a64966a9bfe04e46701cf9193b6c152253eacefa409897b7190b4ed658c5b43026d64dd1f4997811eabbfc4e6cf123fcdf34caf2855a8fc6efd53cd44b8cb79a4717d3a2e28ef489bacca76f5fb4bab0e7756dc82fb01412728082024540be7d5b23d0ab84994a0a4eb29a835aeb07da7b082b1887cdf05efaf9a08df5a4f57000b306845c16c12c978dfccf258d6e896029a177f7c0750dbe3a89d40d9f23412c4ba9f4358864e1463671c186ce368c948d202c233e543699547a18537d9b73bf9558f0955f760ed326946dd0efa870c19a1e538578045f588799f027145333433d2e42f109b06233ba2a49f06c7a1b082aa789f9cbe933a5c4b05c20eea804a5d77c0b55ed088be784630e5c428efed17ee6af9163362d09f5d4755d655bfb5a345a0d5a5363ef35ddd9a75ed5de0efa825593d90ab32e634cb9916f5fb7e207d367ac7543c328edfbb92e74ca0f148cf71be78c30702a87f83290ca3c11d0886beece75730f4c730dbb75d293bce9cb9553b5f2c39fe999771d403cc7074ffc6137645bf4f81840cb8dd1dcaf0d1d847be167487458fb8a345194236ee737efc9f1970447b1f7ac538641b2252442a1ecfcd7f427d5c179875aa1ef5d2f9f4e55ad568ce84adaa7cd3d7964647006c88888aa29bbfb7ffe1b397f066c5bb50e6b51bbe3905ff1879b05d46801917d7066cdcff5b796fd73eced6b166c6756281d1193a33ad6ee2045f277c6553e1e8c2963da8f5d47db9217cae64adf3a3cd7d05e9c51d2f8bc00dd202a29a6d1ee1704c11c4eb8064005b5ef185be2db2d2cad3c1703d18000c35f868d1dc6939866f546d1479ed4363cd31fef72b10839b72f783c6a8e0fc8d445a1a066e9959da4365543e4db13fb94ef34a847869ce62ace995a46d4111e7f2e9b2876dbf6dd249ff074df6c3b9d85921c0db8c85e3df557317cec06089549b7f74c83a27537e24a069caf40a16fb5cdad5e8b0048e75fab5088f8bc6b7ff219556af4e623f4d537bb701d84cdc7acd72ae220d50305dba6567c3a5585058976e0bcfcd20a21c1b441c6ff6e7b07e700e59fbfaaa1dcb6e211e883d09936e34f737370ddb33beca92cb06e3c94cdc218b94385d02facae3104989fc482674d2a4fe6e1140925662f13b6d64a9fe0468d03f5cc28a3ec9e4aaf52aa401bafcd7dc3928f419b79a0be718d93d8140299fe2a7394558fd8ea540948f1898b2c27d51205bf21fda4a682797f513600f13ca294b0ac9ebf035e5b0dd4e48626099356d60adfc10b5124ef0ad9d12f1242d383df8d7f306f4cbd066cf4c884d8e6a093bb662027e028e2860f8b29524c8e5315ee40f74402a836496cdeefcabbab31b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"168799c263c182267b3a05666ca88955"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
